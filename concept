Style:
app.scss file is the root file, so usually the root file, it contains a bunch of imports.
- means you don't define a bunch of selector, instead you load in the file that do that work.
All the files that are imported into app.scss are essentially copy-and-pasted in
the order that they are imported in. That means that all variables are available
in all the imported files since the _variables.scss is imported first.

Create 2 new folder, 1 is base(spacing, or color, or variables file), and the other is components (custom component that we want to style, Ex: nav, and clock widget)


Basic of Testing:
Test simple JS component:
* JSBin: to write a few function and check if everything passes.
* assertion library: handle tool for testing
  - Michael Jackson expect: get the installation and put the script tag into JSBin.
  -then put just Console, and JS and start testing,
    create a function, and then if you want to do it manual you do test the function manually,
    but if you want to test it automated, you have to inset assertion
    Ex: toBe => we check if the two value is the same expect(object).toBe(value,[message]), expect(add(3,5)).toBe(8);

Installing Test into webpack config:
npm install karma@0.13.22 karma-chrome-launcher@0.2.2 karma-mocha@0.2.2 karma-mocha-reporter@2.0.0 karma-sourcemap-loader@0.3.7 karma-webpack@1.7.0 mocha@2.4.5 expect@1.14.0

Karma is a test runner, Mocha: series of function to make JS test easy

you have to do karma.conf.js to place the config, and set the test in package.json for the test to karma start-> to tell the karma start when doing npm test
for testing just do npm test

/* testing in the test file will be like this */
var expect = require('expect');
describe('App', ()=>{ // it will have app keyword and tell if the test is success or not
  it('should properly run tests', () => { // the test for karma for create the comment on the test, the it fuction is telling what the test should do
    expect(1).toBe(1);
  });
}); // strictly visual fucntion, format output to be more readible

In general, it is best to keep libraries small and specific. In the case of expect, it's only job is to
assertion. Karma is responsible for running the test. Mocha is the framework that lets you create individual
test cases and test suites using describe(), it(), beforeEach().. etc.

karma.conf -> how we want to run our test, such as browsers use chrome browser, or framework, we want to use mocha
browser.


* the tests folder will mirror the directory of app, so inside there will have components, and it will have
the clock.test.jsx.
* a few more function and methods to make test easier: it will take the format method and it will return the numebr
as a string. react-addons-test-utils and it needs to match the version number of react and react-dom.

* to test the function using spy (which is a function) so in that sense, it test whether the function should be
called or not, and we can expect on what the function can be called with


flex:
Flexbox is an alternative to inline and block display modes. It has become popular over the last few years because it simplifies otherwise complex layouts. Flexbox makes it simple to create grids, columns, and responsive layouts.
I always recommend A Complete Guide To Flexbox. It's a fantastic reference and it has some real-world examples near the end.

Component Life Cycle:
These method let you run code when certain things happened to your component.

componentWillUnmount:
* tab in into the function when component get removed, so when
the component is switch from countdown to timer, it will fire the function.(when put componentWillUnmount in Countdown)
* automatically gets fired by react, when visually get removed in the browser, right before
your component get removed from the DOM.

componentWillMount:
* gets fired as your component first gets mounted, meaning if the component gets render to the screen
the componentWillMount will called just before it gets shown to the screen.
  * it doesn't have any access to the refs of the DOM, so if you want to make changes to the value of the
  input field, or fetch values, you can't do that in componentWillMount.

componentDidMount:
* gets fired after everything got rendered, you are able to have access to any refs if you want to do
updating.
Ex: componentDidMount: function(){
  console.log('componentDidMount');
},


componentWillMount will get fired first before componentDidMount.
Ex: componentWillMount: function(){
  console.log('componentWillMount');
},

componentDidUpdate: gets fired when an update to your application, either props or state.
/* inside of the funciton there is nothing changes, so if you want to do this.setState nothing
will change because it is before you update the props or state, but you can get the nextState, or nextProps */
  componentWillUpdate: function(nextProps, nextState){

},


componentWillUpdate: gets fired before the update, and it will take the nextProps and the nextState.
componentWillReceivedProps: take argument of (newProps)
* updating props: how? in countdown, when the status changes, it will passed in a different props, so like
clock its props totalSeconds props get updated every seconds.
ex: componentWillReceiveProps: function(newProps){
  /* track the countdown status props that is pass in from countdown in the console as it changes */
  console.log('componentWillReceiveProps', newProps.countdownStatus);

},
